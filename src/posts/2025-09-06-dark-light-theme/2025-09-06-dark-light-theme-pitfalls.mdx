---
slug: 2025-09-06-dark-light-theme
title: SSR, Hydration errors, and why you're dark theme implementation is wrong.
date: '2025-09-06'
subtitle: unless you touch your index.html.
---

When I was looking at the light/dark theme toggle in this blog, it occured to me that the way I'd always done it was not the right way. And likely, the majority of these guides on "how to implement dark theme" are also doing it incorrectly. 

Particularly if you are using some kind of framework like Next.js where you do some kind of server-side rendering.

## Some Background

This is probably the question to ask yourself. How do React's hooks work? When do they run?

### Client-Side Rendering

Now, if you've built a basic React application like the one you're on, you've probably done what is called "client-side rendering".

Here is how it goes.

1. The browser makes a request.
2. The browser downloads an "empty" HTML with some scripts and resources.
3. The browser downloads your React application.
4. The browser executes the React application.
5. The React application renders the UI.

Pretty simple, right? But if you use something like Next.js, how your UI gets rendered probably looks a little different.

### Server-Side Rendering

As you may know, the rendering is split into two parts.

1. The browser makes a request.
2. The server takes your "empty" HTML, and executes (some parts of) your React application, rendering the initial UI.
3. The browser downloads the HTML file, and immediately renders the UI.
4. The browser downloads the React application.
5. The browser executes the React application.
6. The React application hydrates the UI, and makes it interactive.

The user now sees the initial UI much *faster*, because the HTML file comes with the initial UI. Even better, search engine crawlers can now see content properly and render your site.

Now, step 2 can happen in many different ways. When you do it manually on your local machine and upload it to a CDN, it might be called static site generation (SSG). 

Or you could cache the result from the server, and served the cached copy, which Next.js calls Incremental Static Regenration (ISR).

But the gist is, you create the UI, and serve it to the user.

## The Problem

Here is a pretty common implementation of how a dark/light theme toggle may be selected.

We use a `ThemeContext` to store the theme. Initialize the theme in a `useEffect`, checking both `localStorage` and the system preference.

```ts
const ThemeContext = createContext();

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  // Initialize theme
  useEffect(() => {
    const savedTheme = localStorage.getItem('theme');
    const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    // theme = localStorage (system preference as fallback)
    setTheme(savedTheme || (systemPrefersDark ? 'dark' : 'light'));
  }, []);

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  return useContext(ThemeContext);
}
```

### SSR and State

When we do any kind of server-side rendering, we run in to a fundamental issue.

When you render the initial UI on the server, the server can't possibly know the user's theme preference, or the system preference. Should we have the initial UI as light, or dark theme?

Let's go through the SSR steps once again, focusing on the theme issue.

1. The browser makes a request.
2. The server renders the initial UI **but doesn't know the user's theme preference, so it defaults to light.**
3. The browser downloads the HTML file, and immediately renders the UI.
4. The browser downloads the React application.
5. The browser executes the React application. It goes *whoops, it's supposed be dark all along!*
6. Your React application quickly switches the theme to the correct one.
7. The React application hydrates the UI, and makes it interactive.

See the issue here? You just blinded a poor dude for half a second. This visual inconsistency is also commonly called a **Flash of Unstyled Content (FOUC)**. Some libraries will give you a hydration error as well.

The Material UI documentation has a very good gif to show this issue.

![Illustration of dashboard in light mode, then flashing dark.](./dark-mode-flicker-mui.gif "Source: https://mui.com/material-ui/customization/dark-mode/#the-problem")



## A Common Pitfall

One intuitive solution is to delay rendering the app until the theme is determined. Something like this:

```tsx
export const WrapperAroundYourApp = () => {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted)
    return <LoadingScreen />;

  return (
    <ThemeContext>
      <App />
    </ThemeContext>
  )
}
```

Or you can lazy-load your component:

```tsx
const App = lazy(() => import('./App'));

export const WrapperAroundYourApp = () => {
  return (
    <ThemeContext>
      <Suspense fallback={<LoadingScreen />}>
        <App />
      </Suspense>
    </ThemeContext>
  )
}
```

This is a **bad solution**. The problem with this approach is that a you will completely negate the benefits of server-side rendering. Let's take a look again at the rendering steps now:

1. The browser makes a request.
2. The server renders the initial UI. *But the elements that need the theme will not be rendered, either due to lazy loading or an if condition.*
3. The browser downloads the HTML file, and immediately renders the UI. *But again, the majority of your UI is still not rendered.*
4. The browser downloads the React application.
5. The browser executes the React application.
6. The React application hydrates the UI, and makes it interactive.

So, we render a minimal UI on the server-side, and fetch the React application to render the main UI. Doesn't this look identical to client-side rendering? 

We lose **all** the benefits of server-side rendering here. The user does not see the UI until we download the JavaScript bundles, and your site cannot be indexed by search engines. 

In fact, the lazy loading solution will probably have even *worse* performance than your normal CSR, because your critical resources are now considered low-priority.

It is okay to defer rendering, or lazy load non-critical components. But likely, your theme context will span the entire application, and these workarounds are almost equivalent to disabling SSR entirely.

## Some Solutions

There are two fundamental solutions to this issue. You can:
1. Put a blocking script at the start of your `index.html` file, or
2. Store your theme preference in a cookie.

The first is significantly simpler than the second, but it also brings some limitations.

### 1. Insert a blocking script

Instead of checking the user's theme preference in the `useEffect`, you can check it in a blocking script *before* any content renders.

Your `index.html` may look like this:

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="color-scheme" content="light dark" />
    <link rel="icon" type="image/svg+xml" href="/corgi_circle_144x144.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script>
      (function(){
        const theme = localStorage.getItem('theme')
          || (window.matchMedia("(prefers-color-scheme: dark)").matches ? 'dark' : 'light')
        document.documentElement.setAttribute('data-theme', theme)
      })()
    </script>
    <!-- The rest of your head -->
  </head>
  <body>
    <!-- Your body here -->
  </body>
</html>
```

We store the theme somewhere that can be queried by CSS. In this case, we store it in the `data-theme` attribute on the `html` element.

Your context provider can just read this attribute:

```ts
export function ThemeProvider({ children }) {
  const [theme, _setTheme] = useState('light');

  useEffect(() => {
    const theme = document.documentElement.getAttribute('data-theme');
    setTheme(theme);
  }, []);

  const setTheme = (theme) => {
    _setTheme(theme);
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('theme', theme);
  }

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}
```

Your CSS may now look like this:

```css
:root {
  --color-bg: #fff;
  --color-text: #000;
}

:root[data-theme='dark'] {
  --color-bg: #000;
  --color-text: #fff;
}
```

With these changes, the rendering process now looks like this:

1. The browser makes a request.
2. The server renders your React application with a default theme (typically light).
3. The browser downloads the HTML file, and runs the blocking script to set the theme.
4. The browser renders the UI with the correct theme, based on your CSS.
5. The browser downloads the React application.
6. The browser executes the React application and reconciles the theme state. **But because the theme is already set in the CSS, React doesn't need to do anything.**
7. The React application hydrates the UI, and makes it interactive.

The key insight here is that while React still reconciles the theme state during hydration (step 6), the user never sees a visual flicker because the CSS has already applied the correct theme styling from step 4. React updates its internal state to match what's already displayed.

There you go, no FOUC.

#### The Catch

The *catch* to this approach is that your theming **must go through CSS**. If you have some code like this:

```js
const SomeComponent = () => {
  const { theme } = useTheme()

  return (
    {theme === 'dark' ? <DarkComponent /> : <LightComponent />}
  )
}
```

We are back to square one, because now the React application is only rendered correctly *after* the initial DOM render.

### 2. Use a Cookie

Logically, if you have an issue because the server does not know the client state, you can solve the problem by *sending* the client state to the server.

This is a bit more involved, but the most convenient way to do this is with a cookie.

Here is what your ThemeProvider may look like:

```jsx
export function ThemeProvider({ children }) {
  const [theme, _setTheme] = useState('light');

  const setTheme = (newTheme) => {
    _setTheme(newTheme);
    // Set cookie with proper attributes
    document.cookie = `theme=${newTheme}; path=/; max-age=31536000; SameSite=Lax`;
    // Update data-theme attribute for CSS theming
    document.documentElement.setAttribute('data-theme', newTheme);
  };

  // only run on client side
  useEffect(() => {
    const cookieValue = document.cookie
      .split('; ')
      .find(row => row.startsWith('theme='))
      ?.split('=')[1];
    
    if (cookieValue) {
      setTheme(cookieValue);
    } else {
      // Fallback to system preference if no cookie
      const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const preferredTheme = systemPrefersDark ? 'dark' : 'light';
      setTheme(preferredTheme);
    }
  }, []);

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}
```

Next, you need to configure your SSR server to receive the cookie correctly, and select the proper theme while rendering. Your mileage may vary, depending on your server setup and framework, something like `cookies()` from `next/headers` in a Next.js setup.

Your cookie also needs to have `SameSite=Lax` enabled, so that it will be sent with cross-site requests.

While you will not be able to cache your pages with this approach, this is a far more comprehensive solution, because it guarantees that the theme will be resolved correctly on the server every time.

We *cannot* cache the rendered HTML because pages now vary per user preference—a user with dark theme preference needs different HTML than a user with light theme preference. This breaks static caching at the CDN level unless you segment by cookie values.

So, here are the two solutions. You can either insert a blocking script, or transmit the theme preference as a cookie. Or I suppose it does not matter if you're on CSR.

## How do libraries do it?

### `next-themes`

`next-themes` injects a script on the server-side with a `dangerouslySetInnerHTML` attribute, on the [`<ThemeScript>`](https://github.com/pacocoursey/next-themes/blob/main/next-themes/src/index.tsx#L187) element. The script looks like this:

```typescript
export const script = (
  attribute,
  storageKey,
  defaultTheme,
  forcedTheme,
  themes,
  value,
  enableSystem,
  enableColorScheme
) => {
  const el = document.documentElement
  const systemThemes = ['light', 'dark']

  function updateDOM(theme: string) {
    const attributes = Array.isArray(attribute) ? attribute : [attribute]

    attributes.forEach(attr => {
      const isClass = attr === 'class'
      const classes = isClass && value ? themes.map(t => value[t] || t) : themes
      if (isClass) {
        el.classList.remove(...classes)
        el.classList.add(value && value[theme] ? value[theme] : theme)
      } else {
        el.setAttribute(attr, theme)
      }
    })

    setColorScheme(theme)
  }

  function setColorScheme(theme: string) {
    if (enableColorScheme && systemThemes.includes(theme)) {
      el.style.colorScheme = theme
    }
  }

  function getSystemTheme() {
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'
  }

  if (forcedTheme) {
    updateDOM(forcedTheme)
  } else {
    try {
      const themeName = localStorage.getItem(storageKey) || defaultTheme
      const isSystem = enableSystem && themeName === 'system'
      const theme = isSystem ? getSystemTheme() : themeName
      updateDOM(theme)
    } catch (e) {
      //
    }
  }
}
```

### Material UI

Material UI also uses a similar [approach](https://github.com/mui/material-ui/blob/master/packages/mui-system/src/InitColorSchemeScript/InitColorSchemeScript.tsx) to inject the script:

```tsx
export default function InitColorSchemeScript(options?: InitColorSchemeScriptProps) {
  // lots of logic here
  return (
    <script
      key="mui-color-scheme-init"
      suppressHydrationWarning
      nonce={typeof window === 'undefined' ? nonce : ''}

      // INJECT SCRIPT FOR THEME!!
      // eslint-disable-next-line react/no-danger
      dangerouslySetInnerHTML={{
        __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${modeStorageKey}') || '${defaultMode}';
  const dark = localStorage.getItem('${colorSchemeStorageKey}-dark') || '${defaultDarkColorScheme}';
  const light = localStorage.getItem('${colorSchemeStorageKey}-light') || '${defaultLightColorScheme}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${setter}
  }
} catch(e){}})();`,
      }}
    />
  );
}
```

### Radix, Tailwind, Mantine

Libraries like Radix, Tailwind, and Mantine are unopinionated about where the dark mode comes from. 

In Radix, you can append any class names to the root element. Tailwind, on the other hand, lets you write your own CSS selectors to determine the dark mode. 

Mantine uses the [`light-dark`](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/light-dark) CSS function to determine styles for light and dark mode. 

## Conclusion

So there we have it. The notion of this separate state between client and server during server-side rendering is not just a problem for light/dark mode, it is a problem *anytime* your UI render depends on any kind of state, and is the reason why some state management libraries like Jotai have [hooks](https://jotai.org/docs/utilities/ssr) specifically for SSR.

Technically, there are two solutions.
1. **Use a blocking script** - It is the simplest solution, and works great if you can stick to CSS-based theming.
2. **Pass the theme as a cookie** - It is much more complex, but gives you full flexibility. But it has implications for your cache architecture.

It seems that most popular libraries like `next-themes` and Material UI have settled on the blocking script approach, and for good reason. We have great support for light/dark mode in CSS, and it is very easy to implement.

I hope this serves as a good introduction to state management in SSR. Any client-specific state—locale, feature flags, AB tests, device preferences, come with the same considerations. We should understand why SSR came about in the first place, and the considerations behind each solution.  